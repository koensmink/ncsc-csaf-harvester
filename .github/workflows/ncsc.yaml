name: NCSC CSAF Harvester

on:
  schedule:
    # Doordeweeks (ma-vr) elk uur om xx:00 UTC
    - cron: "0 * * * 1-5"
    # Weekend-runs die samen 23:55 NL-tijd afdekken (CET/CEST)
    - cron: "55 21 * * 6,0"  # dekkend voor CEST (UTC+2)
    - cron: "55 22 * * 6,0"  # dekkend voor CET (UTC+1)
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: ncsc-csaf-harvester
  cancel-in-progress: false

jobs:
  harvest:
    runs-on: self-hosted

    steps:
      # Gate: in het weekend alleen doorlopen als het lokaal 23:55 is
      - name: Weekend 23:55 Europe/Amsterdam gate
        run: |
          DOW=$(TZ=Europe/Amsterdam date +%u)   # 1=ma ... 7=zo
          HM=$(TZ=Europe/Amsterdam date +%H:%M)
          if [ "$DOW" -ge 6 ]; then
            if [ "$HM" != "23:55" ]; then
              echo "Weekend en lokale tijd is $HM, niet 23:55 â€” job wordt overgeslagen."
              exit 0
            fi
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          else
            pip install feedparser
          fi

      - name: Run scraper
        run: python scraper.py

      # Alleen melden wanneer [H/H], [M/H] of [H/M] voorkomt â€” zonder "Hoog-risico..." of timestamp
      - name: Notify Telegram (only on [H/H], [M/H], [H/M])
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          python - <<'PY'
          import os, json, csv, re, glob, subprocess, pathlib

          token = os.getenv("TELEGRAM_BOT_TOKEN","").strip()
          chat  = os.getenv("TELEGRAM_CHAT_ID","").strip()
          if not token or not chat:
              raise SystemExit(0)

          def send(msg: str):
              # Gebruik --data-urlencode zodat nieuwe regels/UTF-8 goed gaan
              subprocess.run([
                  "curl","-sS","-X","POST", f"https://api.telegram.org/bot{token}/sendMessage",
                  "--data-urlencode", f"chat_id={chat}",
                  "--data-urlencode", f"text={msg}",
                  "--data-urlencode", "disable_web_page_preview=true"
              ], check=False)

          # Vind CSV van de laatste run
          data = {}
          try:
              with open("output/last_run.json", encoding="utf-8") as f:
                  data = json.load(f)
          except Exception:
              pass

          csv_path = data.get("csv_path", "")
          if not csv_path or not os.path.exists(csv_path):
              files = sorted(glob.glob("output/daily/*.csv"), key=os.path.getmtime, reverse=True)
              csv_path = files[0] if files else ""

          if not csv_path or not os.path.exists(csv_path):
              raise SystemExit(0)

          # Helpers om tag/titel/url robuust te vinden
          TAG_RE = re.compile(r"\[(H/H|M/H|H/M)\]", re.IGNORECASE)

          def find_tag(d):
              for v in d.values():
                  if isinstance(v, str):
                      m = TAG_RE.search(v)
                      if m:
                          return f"[{m.group(1).upper()}]"
              return ""

          def find_title(d):
              for k in ("title","Title","advisory_title","name","summary","headline"):
                  v = d.get(k)
                  if isinstance(v,str) and v.strip():
                      return v.strip()
              # fallback: eerste niet-lege tekstveld
              for v in d.values():
                  if isinstance(v,str) and v.strip():
                      return v.strip()
              return "(zonder titel)"

          def find_url(d):
              for k in ("url","URL","link","advisory_url","reference","reference_url","canonical_url"):
                  v = d.get(k)
                  if isinstance(v,str) and v.startswith(("http://","https://")):
                      return v.strip()
              for v in d.values():
                  if isinstance(v,str) and v.startswith(("http://","https://")):
                      return v.strip()
              return ""

          rows = []
          with open(csv_path, encoding="utf-8", newline="") as f:
              sample = f.read(4096)
              f.seek(0)
              try:
                  dialect = csv.Sniffer().sniff(sample)
              except Exception:
                  dialect = csv.excel

              try:
                  reader = csv.DictReader(f, dialect=dialect)
              except Exception:
                  reader = None

              if reader and reader.fieldnames:
                  for d in reader:
                      tag = find_tag(d)
                      if not tag:
                          continue
                      title = find_title(d)
                      url   = find_url(d)
                      rows.append((tag, title, url))

          if not rows:
              raise SystemExit(0)

          # Bouw bericht (zonder "Hoog-risico..." en zonder timestamp)
          lines = ["ðŸš¨ðŸ™‚ URGENT"]
          if len(rows) > 1:
              lines.append("") ; lines.append("Details:")
          for tag, title, url in rows[:20]:
              lines.append(f"â€¢ {tag} â€” {title}")
              if url:
                  lines.append(f"  {url}")
          if len(rows) > 20:
              lines.append(f"â€¦ en nog {len(rows)-20} meer.")

          send("\n".join(lines))
          PY

      - name: Commit & push outputs
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "Automated NCSC advisories update"
          git pull --rebase --autostash
          git push
